
my.prepareEnrichNet<-function(netNm, type, overlapType){
  save.image("enr.RData");
  if(is.null(enr.mat)){
    return(0);
  }
  hits <-  enr.mat[,"Hits"];
  pvals <- enr.mat[,"P.Value"];
  require(igraph);
  require(reshape);
  pvalue <- pvals;
  id <- names(pvalue);
  current.geneset <- qs::qread("current_geneset.qs");
  hits.query <- qs::qread("hits_query.qs")
  hits.query <- hits.query[rownames(enr.mat)];
  geneSets <- hits.query;
  n <- length(pvalue);
  w <- matrix(NA, nrow=n, ncol=n);
  colnames(w) <- rownames(w) <- id;
  
  for (i in 1:n) {
    for (j in i:n) {
      w[i,j] <- overlap_ratio(geneSets[id[i]], geneSets[id[j]], overlapType)
    }
  }
  wd <- melt(w);
  wd <- wd[wd[,1] != wd[,2],];
  wd <- wd[!is.na(wd[,3]),];
  
  g <- graph.data.frame(wd[,-3], directed=F);
  if(type == "list"){
    g <- delete.edges(g, E(g)[wd[,3] < 0.3]);
  }else{
    g <- delete.edges(g, E(g)[wd[,3] < 0.3]);
  }
  idx <- unlist(sapply(V(g)$name, function(x) which(x == id)));
  
  # define local function
  my.normalize <- function(x){
    return((x- min(x)) /(max(x)-min(x)))
  }
  my.rescale <- function(x, from, to){
    (x - min(x)) / max(x - min(x)) * (to - from) + from
  }
  
  V(g)$color <- ComputeColorGradient(-log(my.normalize(pvalue) + min(pvalue/2)), "black", F, F);
  V(g)$colorw <- ComputeColorGradient(-log(my.normalize(pvalue) + min(pvalue/2)), "white", F, F);
  
  cnt <- hits;
  names(cnt) <- id;
  cnt2 <- cnt[V(g)$name];
  
  V(g)$size <- my.rescale(log(cnt2+1, base=10), 8, 32);
  
  # layout
  pos.xy <- layout.auto(g);
  
  # now create the json object
  nodes <- vector(mode="list");
  node.nms <- V(g)$name;
  node.sizes <- V(g)$size;
  node.cols <- V(g)$color;
  node.colsw <- V(g)$colorw;
  
  for(i in 1:length(node.sizes)){
    nodes[[i]] <- list(
      id = node.nms[i],
      label=node.nms[i],
      size = node.sizes[i],
      true_size=node.sizes[i], 
      colorb=node.cols[i],
      colorw=node.colsw[i],
      posx = pos.xy[i,1],
      posy = pos.xy[i,2]
    );
  }
  
  edge.mat <- get.edgelist(g);
  edge.mat <- cbind(id=1:nrow(edge.mat), source=edge.mat[,1], target=edge.mat[,2]);
  
  # covert to json
  bedges <- stack(hits.query);
  b.mat <- matrix(NA, nrow=nrow(bedges), ncol=2);
  b.mat[,1] <- bedges[,"values"];
  b.mat[,2] <- as.character(bedges[,"ind"]);
  b.mat <- b.mat[complete.cases(b.mat),]
  colnames(b.mat) <- c("source", "target");
  bg <- graph.data.frame(b.mat, directed=F);
  idx <- unlist(sapply(V(bg)$name, function(x) which(x == id)));
  cols <- color_scale("red", "#E5C494");
  
  V(bg)$color[V(bg)$name %in% rownames(enr.mat)] <- ComputeColorGradient(-log(pvalue), "black", F, F);
  V(bg)$colorw[V(bg)$name %in% rownames(enr.mat)] <- ComputeColorGradient(-log(pvalue), "white", F, F);
  node.nms <- V(bg)$name;
  if(anal.type == "onedata"){
    tbl <- dataSet$resTable
    tbl <- tbl[which(doEntrez2SymbolMapping(rownames(tbl)) %in% V(bg)$name),]
    expr.val <- tbl[,selectedFactorInx];
    expvals <- expr.val;
    names(expvals) <- doEntrez2SymbolMapping(rownames(tbl))
    expvals <- expvals[node.nms]
    V(bg)$color[!V(bg)$name %in% rownames(enr.mat)] <- ComputeColorGradient(unname(expvals), "black", T, F);
    V(bg)$colorw[!V(bg)$name %in% rownames(enr.mat)] <- ComputeColorGradient(unname(expvals), "black", T, F);
  }else if(anal.type == "genelist" && sum(all.prot.mat[,1]) != 0){
   tbl <- all.prot.mat
    gene.nms <- V(bg)$name[which(!V(bg)$name %in% rownames(enr.mat))]
    tbl <- tbl[which(tbl[,2] %in% gene.nms),]
    expr.val <- tbl[,1];
    names(expr.val) <- tbl[,2]
    expvals <- expr.val
    expvals <- expvals[node.nms]
    expvals <- expvals[!is.na(expvals)]
    V(bg)$color[!V(bg)$name %in% rownames(enr.mat)] <- ComputeColorGradient(unname(expvals), "black", T, F);
    V(bg)$colorw[!V(bg)$name %in% rownames(enr.mat)] <- ComputeColorGradient(unname(expvals), "black", T, F);
    
  }else if(anal.type =="metadata"){
    tbl <- meta.mat.all
    tbl <- as.matrix(tbl[which(doEntrez2SymbolMapping(rownames(tbl)) %in% V(bg)$name),])
    expr.val <- tbl[,1];
    expvals <- expr.val;
    names(expvals) <- doEntrez2SymbolMapping(rownames(tbl))
    expvals <- expvals[node.nms]
    V(bg)$color[!V(bg)$name %in% rownames(enr.mat)] <- ComputeColorGradient(unname(expvals), "black", T, F);
    V(bg)$colorw[!V(bg)$name %in% rownames(enr.mat)] <- ComputeColorGradient(unname(expvals), "black", T, F);
  }else{
    expvals <- rep(0,length(V(bg)$color)); 
    V(bg)$color[!V(bg)$name %in% rownames(enr.mat)] <- "#00FFFF";
    V(bg)$colorw[!V(bg)$name %in% rownames(enr.mat)] <- "#668B8B"
  }
  node.dgr2 <- as.numeric(degree(bg));
  V(bg)$size <- my.rescale(log(node.dgr2, base=10), 8, 24); 
  
  # layout
  pos.xy <- layout.auto(bg);
  
  # now create the json object
  bnodes <- vector(mode="list");
  node.sizes <- V(bg)$size;
  node.cols <- V(bg)$color;
  node.colsw <- V(bg)$colorw;
  
  shapes <- rep("circle", length(node.nms));
  hit.inx <- node.nms %in% b.mat[,"source"];
  shapes[hit.inx] <- "gene";
  node.lbls <- doEntrez2SymbolMapping(node.nms)
  
  for(i in 1:length(node.sizes)){
    bnodes[[i]] <- list(
      id = node.nms[i],
      label=node.lbls[i], 
      size=node.sizes[i], 
      colorb=node.cols[i],
      colorw=node.colsw[i],
      true_size=node.sizes[i], 
      type=shapes[i],
      exp= unname(expvals[node.nms[i]]),
      posx = pos.xy[i,1],
      posy = pos.xy[i,2]
    );
  }
  
  ppi.comps <- vector(mode="list");
  current.net.nm <<- "enrNet"
  ppi.comps[["enrNet"]] <- bg;
  ppi.comps <<- ppi.comps
  
  bedge.mat <- get.edgelist(bg);
  bedge.mat <- cbind(id=1:nrow(bedge.mat), source=bedge.mat[,1], target=bedge.mat[,2]);
  initsbls <- doEntrez2SymbolMapping(list.genes)
  names(initsbls) <- list.genes
  netData <- list(nodes=nodes, edges=edge.mat, bnodes=bnodes, bedges=bedge.mat, enr=enr.mat, id=rownames(enr.mat), sizes=listSizes, hits=hits.query, genelist=initsbls, analType=anal.type, org=data.org, naviString = "Enrichment Network");
  netName <- paste0(netNm, ".json");
  partialToBeSaved <<- c(partialToBeSaved, c(netName))
  dataSet$jsonNms$network <<- netName;
  sink(netName);
  cat(RJSONIO::toJSON(netData));
  sink();
  return(.set.mSet(dataSet));
}
